#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>

using namespace std;

/*
    좌표평면 위에 점 n개, 각 점에서 거리의 합이 최솩 되는 점의 좌표를 정해줘라
    거리는 맨해튼 거리이다.

    모든 점에서의 거리의 합이 최소가 되어야 하므로, 일단 중간에 있어줘야 한다
    거리의 합이 최소가 되려면 어떤 조건을 만족해야 할까?

    하나하나 비교해보기 불가능함.
    10만개가 각각 서로 다른 10만개랑 거리 차이 추정하ㅣㄱ??? 시간상 절대 절대 절대 불가능
    다른 방법 생각해야 한다

    --- 방법 1 -------------------------------------------------
    어떤 점이 x, y라고 할 때,
    0, 0에서 x, y까지의 거리는 x - 0, y - 0 일 것

    1, 1에서는 x - 1, y - 1일 것
    그럼 이걸 결국 다 계산하다보면 Nx - a, Ny - b가 나올 텐데,
    x, y값을 맘대로 잡아서 이걸 최소로 만들기??

    예를 들어 (0,0) (0,1), (3,1)이 있다고 하면
    3x - 3 + 3y - 2가 답이 될 수 있는데, 이를 최소로 만들기 위한 값은 x = 1, y = 1이다.
    그래서 1, 1에 자리를 잡는다?
    근데 이건 x - a와 x - b가 항상 0 이상이라는 조건이 있어야 함.

    그럼 그 어떤 a 나 b보다 항상 x가 커야 하는데, 그럼 최소값을 찾을 수 없음.
    ------------------------------------------------------------

    --- 방법 2 -------------------------------------------------
    가로끼리, 세로끼리 계산하기?

    중요한건, 왼쪽에서 한 칸 오나 오른쪽에서 한 칸 오나 모두 한 칸이라는 것
    그러니 왼쪽에서 오는 친구들, 오른쪽에서 오는 친구들의 개수를 맞춰줘야만 가장 짧은 거리를 찾을 수 있음
    
    두 점 사이에서는 점의 좌표를 포함해 어디를 기준으로 잡든 오는 칸 수가 똑같다. 따라서 점이 짝수개가 있을 때는 중간 두 값 중 사이 어디에 기준을 잡아도 상관없음
    대신 홀수개일때는, 중간점에 딱 있어줘야 함. 아니면 왼쪽과 오른쪽의 점 개수가 달라지므로.
    OK
    */

int main() {
    int N;
    int answer = 0;
    cin >> N;

    vector<int> rows(N);
    vector<int> cols(N);

    for (int i = 0; i < N; i++) {
        cin >> rows[i];
        cin >> cols[i];
    }

    // 정렬
    sort(rows.begin(), rows.end());
    sort(cols.begin(), cols.end());

    // 중간값 잡기
    int row_std = rows[N / 2];
    int col_std = cols[N / 2];
    
    // 거리 합 계산하기
    for (int i = 0; i < N; i++) {
        answer += abs(row_std - rows[i]);
        answer += abs(col_std - cols[i]);
    }

    cout << answer << endl;
    return 0;
}