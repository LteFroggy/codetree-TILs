#include <iostream>
using namespace std;

/*
    괄호로만 있다! 정확히 하나의 소괄호 방향을 바꾸었을 때, 올바른 괄호 순서가 되는 가지수를 구해보자.
    최대 10만 글자이다.

    일단 생각하기 쉬운 방법부터 떠올려보자
    먼저 모든 왼쪽 괄호, 오른쪽 괄호를 센다.
    오른쪽 괄호가 왼쪽 괄호보다 2개 많은 경우, 오른쪽 괄호 하나를 왼쪽 괄호로 바꾸면 옳은 괄호쌍이 될 수도 있다.
    그런데 어떤 것을 바꾸어야 옳은 괄호쌍이 될 수 있는 것일까??
    1 2 3 4 5 6 7 8 9 10
    ( ) ) ( ( ( ) ) ) )
    위와 같은 경우를 생각해보자.
    왼쪽 괄호를 만나면 값을 +1, 오른쪽 괄호를 만나면 값을 -1한다고 했을 때, 값의 진행은 아래와 같다
    1 0 -1 0 1 2 1 0 -1 -2

    오른쪽 괄호를 바꾸는 모든 경우와 그에 따른 값의 진행을 정리해보자.
    
    2번을 변경한 경우
    ( ( ) ( ( ( ) ) ) )
    1 2 1 2 3 4 3 2 1 0

    3번을 변경한 경우
    ( ) ( ( ( ( ) ) ) )
    1 0 1 2 3 4 3 2 1 0

    7번을 변경한 경우
    ( )  ) ( ( ( ( ) ) )
    1 0 -1 1 2 3 4 3 2 1

    8번을 변경한 경우
    ( )  ) ( ( ( ) ( ) )
    1 0 -1 0 1 2 1 2 1 0

    9번을 변경한 경우
    ( )  ) ( ( ( ) ) ( )
    1 0 -1 0 1 2 1 0 1 0

    10번을 변경한 경우
    ( )  ) ( ( ( ) )  ) (
    1 0 -1 0 1 2 1 0 -1 0

    위 경우 중 올바른 괄호쌍이 되지 못하는 경우는 7, 8, 9, 10번이다.
    전개 중 음수값이 생기면 올바른 괄호쌍이라고 할 수 없기 때문이다.

    위의 예시로 우리가 알 수 있는 것은 첫 음수값이 발생한 위치까지의 괄호를 바꿔주는 경우에만 올바른 괄호쌍을 만들 수 있다는 것이다.
    그렇지 않으면 앞에 음수인 쌍이 남아서 올바른 괄호쌍이 되지 못하기 때문이다.

    다음 예시이다.
    1 2 3 4 5 6  7  8
    ( ( ( ) ) )  )  )
    1 2 3 2 1 0 -1 -2
    
    위의 경우에는 첫 음수값이 7번에서 발생했으므로, 4, 5, 6, 7번을 변경한 경우에 올바른 괄호쌍이 될 것이다.
    확인은 아래와 같다.

    1. 4번을 변경한 경우
    ( ( ( ( ) ) ) )
    1 2 3 4 3 2 1 0

    2. 5번을 변경한 경우
    ( ( ( ) ( ) ) )
    1 2 3 2 3 2 1 0

    3. 6번을 변경한 경우
    ( ( ( ) ) ( ) )
    1 2 3 2 1 2 1 0

    4. 7번을 변경한 경우
    ( ( ( ( ) ) ) )
    1 2 3 4 3 2 1 0

    5. 8번을 변경한 경우
    ( ( ( ) ) )  ) (
    1 2 3 2 1 0 -1 0

    역시 8번을 변경한 경우에는 앞에서 음의 값이 나와서 올바른 괄호쌍이 되지 못한다.
    따라서 첫 음수값이 발생한 곳까지의 괄호를 바꿔주어야만 한다.


    그렇다면 왼쪽 괄호를 오른쪽 괄호로 바꿔야 하는 경우에는 어떻게 해야 할까?
    이것은 생각보다 간단하다! 뒤집어서 읽으면 된다. 뒤집어서 읽으면 오른쪽 괄호가 왼쪽 괄호가 되고, 왼쪽 괄호는 오른쪽 괄호가 된다.
    방법은 동일하다. 첫 음수값이 나올때까지의 괄호를 변경하면 된다. 이것도 에시를 들어보자
    6 5 4 3 2 1
    ( ( ( ) ( ) 
    보기 편하게 일단 앞뒤를 뒤집는다.
    1 2 3 4  5 6
    ( ) ( )  ) ) 
    뒤에서부터 값을 판단하면 아래와 같다
    1 0 1 0 -1 0

    그렇다면, 앞에서 했던 것과 마찬가지로 -1이 처음 나온 5번 이전의 오른쪽 괄호를 왼쪽으로 바꿔줘야 할 것이다.
    
    2번을 바꾼 경우         4번을 바꾼 경우         5번을 바꾼 경우         6번을 바꾼 경우
    ( ( ( ) ) )             ( ) ( ( ) )            ( ) ( ) ( )             ( ) ( )  ) ( 
    1 2 3 2 1 0             1 0 1 2 1 0            1 0 1 0 1 0             1 0 1 0 -1 0

    역시 6번을 바꾸면 문제가 생김을 알 수 있다 첫 음수값 이후의 오른쪽 괄호이기 때문.
    이를 생각하면서 문제를 풀어보자.
*/
int answer(0);

int main() {
    
    string brackets;
    cin >> brackets;
    int answer(0);

    int check = 0;
    int left_possible(0), right_possible(0);
    // check값을 수정해가면서 수정 가능한 왼쪽 괄호와 오른쪽 괄호의 개수를 센다
    for (int i = 0; i < brackets.size(); i++) {
        // 먼저 체크값을 수정하고, 만약 이 왼쪽 괄호가 오른쪽 괄호로 바뀌었을 때 문제가 없다면 left_possible을 1 추가시킨다.
        if (brackets[i] == '(') {
            check++;
        }

        else {
            check--;
        }
    }   

    // 만약 다 셌는데 오른쪽 괄호가 두개 더 많다면, )를 (로 바꿔야 하는 경우이다. 정방향으로 진행한다.
    if (check == -2) {
        check = 0;
        for (int i = 0; i < brackets.size(); i++) {
            // 이 경우에는 (를 보면 +1, )가 보이면 -1이다.
            if (brackets[i] == '(') {
                check++;
            }
            else {
                check--;
                answer++;

                // 만약 여기서 첫 음수값이 발생한다면, 여기까지만 봐야 하므로 루프를 종료한다.
                if (check < 0) break;
            }
        }
        cout << answer << endl;
    }

    // 왼쪽 괄호가 두 개 더 많다면, (를 )로 바꿔야 하는 상황이다! 역순으로 본다.
    else if (check == 2) {
        check = 0;
        for (int i = brackets.size() - 1; i >= 0; i--) {
            // 뒤집어서 볼 것이니 )를 만나면 +1, (을 만나면 -1이 된다.
            if (brackets[i] == ')') {
                check++;
            }
            else {
                check--;
                answer++;

                // 만약 여기서 첫 음수값이 발생한다면, 여기까지만 봐야 하므로 루프를 종료한다.
                if (check < 0) break;
            }
        }
        cout << answer << endl;
    }


    // 아예 2나 -2가 아니라면, 애초에 멀쩡해질 수가 없는 문자열이다.
    else {
        cout << 0 << endl;
    }

    return 0;
}